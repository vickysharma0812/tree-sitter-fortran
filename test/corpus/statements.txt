============================================
Include Statements
============================================

PROGRAM TEST
  INCLUDE 'fftw.f03'
  a = 1.0
  INCLUDE 'debug_point.f03'
END PROGRAM

----

(translation_unit
  (program
    (program_statement (name))
    (include_statement (filename))
    (assignment_statement (identifier) (number_literal))
    (include_statement (filename))
  (end_program_statement)))

============================================
Use Statements
============================================

PROGRAM TEST
  USE ISO_C_BINDING
  USE ISO_FORTRAN_ENV, ONLY : ERROR_UNIT, OUTPUT_UNIT
  USE MY_MODULE, ONLY:FUNC1
  use, intrinsic :: iso_fortran_env
  use, non_intrinsic :: iso_varying_string
  use my_module, only: func2 => foo
  use, intrinsic:: iso_fortran_env, stderr => error_unit
  use :: some_mod
  use some_mod, only:
  use some_mod, func2 => foo
END PROGRAM

----

(translation_unit
  (program
    (program_statement (name))
    (use_statement (module_name))
    (use_statement (module_name)
      (included_items (identifier) (identifier)))
    (use_statement (module_name)
      (included_items (identifier)))
    (use_statement (module_name))
    (use_statement (module_name))
    (use_statement (module_name)
      (included_items (use_alias (local_name) (identifier))))
    (use_statement (module_name)
      (use_alias (local_name) (identifier)))
    (use_statement (module_name))
    (use_statement (module_name)
      (included_items))
    (use_statement (module_name)
      (use_alias (local_name) (identifier)))
  (end_program_statement)))

============================================
Implicit Statements
============================================

PROGRAM TEST
  IMPLICIT INTEGER(i - n), REAL(8)(r-z),  COMPLEX*8(a - c, d, e-h)
  IMPLICIT NONE
  implicit none (type, external)
END PROGRAM

----

(translation_unit
  (program
    (program_statement (name))
    (implicit_statement
      (intrinsic_type) (implicit_range)
      (intrinsic_type) (size (argument_list (number_literal))) (implicit_range)
      (intrinsic_type) (size) (implicit_range) (implicit_range) (implicit_range))
    (implicit_statement (none))
    (implicit_statement (none))
  (end_program_statement)))

============================================
Save Statements
============================================

MODULE TEST
  SAVE
  SAVE :: a, b, c, d_1
END MODULE

----

(translation_unit
  (module (module_statement (name))
    (save_statement)
    (save_statement (identifier) (identifier) (identifier) (identifier))
    (end_module_statement)))

============================================
Private Statements
============================================

MODULE TEST
  PRIVATE
  PRIVATE :: a, b_1, operator(.and.), operator(+)
END MODULE

----

(translation_unit
  (module (module_statement (name))
    (private_statement)
    (private_statement (identifier) (identifier) (operator) (operator))
    (end_module_statement)))

============================================
Public Statements
============================================

MODULE TEST
  PUBLIC
  PUBLIC :: a, b_1, operator(.and.), operator(+)
END MODULE

----

(translation_unit
  (module (module_statement (name))
    (public_statement)
    (public_statement (identifier) (identifier) (operator) (operator))
    (end_module_statement)))

============================================
Intrinsic Variable Declarations
============================================

PROGRAM TEST
  INTEGER, PARAMETER :: N = 100, MXLN = 255
  INTEGER :: i, j, k, l(*)
  REAL(16) :: data(0:N**2), rhs(N), lhs(0:*)
  REAL*8, TARGET :: tmp
  REAL(KIND=8), CONTIGUOUS, POINTER :: nxt => tmp
  LOGICAL, DIMENSION(:), ALLOCATABLE :: mask
  CHARACTER(LEN=:) :: message
  CHARACTER(LEN=*) :: options
  CHARACTER*(MXLN) :: errflag
  CHARACTER(*) :: thing
  CHARACTER   FMAT*22, OTHER*(*)
  integer::no_whitespace=1
END PROGRAM

----

(translation_unit
  (program
    (program_statement (name))
    (variable_declaration (intrinsic_type) (type_qualifier)
      (assignment_statement (identifier) (number_literal))
      (assignment_statement (identifier) (number_literal)))
    (variable_declaration (intrinsic_type)
      (identifier)
      (identifier)
      (identifier)
      (call_expression (identifier) (argument_list (assumed_size))))
    (variable_declaration (intrinsic_type) (size (argument_list (number_literal)))
      (call_expression (identifier)
        (argument_list
          (extent_specifier (number_literal) (math_expression (identifier) (number_literal)))))
      (call_expression (identifier) (argument_list (identifier)))
      (call_expression (identifier) (argument_list
          (extent_specifier (number_literal) (assumed_size)))))
    (variable_declaration (intrinsic_type) (size) (type_qualifier) (identifier))
    (variable_declaration
      (intrinsic_type) (size (argument_list (keyword_argument (identifier) (number_literal))))
      (type_qualifier)
      (type_qualifier)
      (pointer_association_statement (identifier) (identifier)))
    (variable_declaration
      (intrinsic_type)
      (type_qualifier (argument_list (extent_specifier)))
      (type_qualifier) (identifier))
    (variable_declaration
      (intrinsic_type)
        (size (argument_list (keyword_argument (identifier) (assumed_shape))))
      (identifier))
    (variable_declaration
      (intrinsic_type)
      (size (argument_list (keyword_argument (identifier) (assumed_size))))
      (identifier))
    (variable_declaration
      (intrinsic_type) (size (assumed_size) (argument_list (identifier)))
      (identifier))
    (variable_declaration
      (intrinsic_type) (size (argument_list (assumed_size)))
      (identifier))
    (variable_declaration
      (intrinsic_type)
      (identifier) (character_length)
      (identifier) (character_length))
    (variable_declaration
      (intrinsic_type)
      (assignment_statement (identifier) (number_literal)))
  (end_program_statement)))

============================================
Derived Type Variable Declarations
============================================

PROGRAM TEST
  TYPE(CUSTOM_TYPE) :: CT
  type(real) :: r
  type(real(real32)) :: r32
  type(real(kind(1.d0))) :: r64
  class(custom_type), pointer :: cl
  class(*), pointer :: up
END PROGRAM

----

(translation_unit
  (program
    (program_statement (name))
    (variable_declaration (derived_type (type_name)) (identifier))
    (variable_declaration (derived_type (intrinsic_type)) (identifier))
    (variable_declaration
      (derived_type
        (intrinsic_type) (size (argument_list (identifier))))
      (identifier))
    (variable_declaration
      (derived_type
        (intrinsic_type)
        (size (argument_list (call_expression (identifier) (argument_list (number_literal))))))
      (identifier))
    (variable_declaration (derived_type (type_name)) (type_qualifier) (identifier))
    (variable_declaration
      (derived_type (unlimited_polymorphic)) (type_qualifier)
      (identifier))
  (end_program_statement)))

============================================
Derived Type Procedure Arguments
============================================

module foo
contains

subroutine test(arg1, arg2)
  type(dt), intent(in) :: arg1
  type(real), intent(out) :: arg2
end subroutine test

subroutine test2(arg1, arg2)
  class(dt), intent(in) :: arg1
  type(real(real32)), intent(out) :: arg2
end subroutine test2

subroutine test3(arg1, arg2)
  class(*), intent(in) :: arg1
  type(real(kind(1.0d0))), intent(out) :: arg2
end subroutine test3

end module foo

---

(translation_unit
  (module
    (module_statement (name))
    (internal_procedures
      (contains_statement)
      (subroutine
        (subroutine_statement (name)
          (parameters (identifier) (identifier)))
        (variable_declaration
          (derived_type (type_name)) (type_qualifier) (identifier))
        (variable_declaration
          (derived_type (intrinsic_type)) (type_qualifier) (identifier))
        (end_subroutine_statement (name)))
      (subroutine
        (subroutine_statement (name)
          (parameters (identifier) (identifier)))
        (variable_declaration
          (derived_type (type_name)) (type_qualifier) (identifier))
        (variable_declaration
          (derived_type (intrinsic_type)
            (size (argument_list (identifier))))
          (type_qualifier) (identifier))
        (end_subroutine_statement (name)))
      (subroutine
        (subroutine_statement (name)
          (parameters (identifier) (identifier)))
        (variable_declaration
          (derived_type (unlimited_polymorphic)) (type_qualifier) (identifier))
        (variable_declaration
          (derived_type (intrinsic_type)
            (size (argument_list
                (call_expression (identifier) (argument_list (number_literal))))))
          (type_qualifier) (identifier))
        (end_subroutine_statement (name))))
    (end_module_statement (name))))

============================================
Variable Modification Statements
============================================

PROGRAM TEST
  ALLOCATABLE :: i
  DIMENSION i(:, :), r(10)
  TARGET :: i
  PARAMETER (MAXLEN = 255, PI = 3.1415, SCALE_FACTOR = SIN(2 * PI))
  EQUIVALENCE (a, b, c), (d, e, f, r(1))
  SAVE A, B, /BLOCKC/, D
END PROGRAM

----

(translation_unit
  (program
    (program_statement (name))
    (variable_modification (type_qualifier) (identifier))
    (variable_modification (type_qualifier)
      (call_expression (identifier) (argument_list (extent_specifier) (extent_specifier)))
      (call_expression (identifier) (argument_list (number_literal))))
    (variable_modification (type_qualifier) (identifier))
    (parameter_statement
      (parameter_assignment (identifier) (number_literal))
      (parameter_assignment (identifier) (number_literal))
      (parameter_assignment (identifier)
        (call_expression (identifier)
          (argument_list (math_expression (number_literal) (identifier))))))
    (equivalence_statement
      (equivalence_set (identifier) (identifier) (identifier))
      (equivalence_set
        (identifier)
        (identifier)
        (identifier)
        (call_expression (identifier) (argument_list (number_literal)))))
    (save_statement (identifier) (identifier) (identifier) (identifier))
  (end_program_statement)))

============================================
Do Loops
============================================

PROGRAM TEST
    DO i = 1, 10
      x = 6**x
      OPEN(i, FILE="qwerty")
      CALL MYSUB(i, TEST=.TRUE.)
    END DO

    DO i = 1, UBOUND(arr), step
      CONTINUE
      GOTO 44
    ENDDO

    out44: DO i = 1,INT(SIN(9.0*i))
      DO j = 1, 100, -1
        CYCLE out44
      END DO
    END DO out44

    DO WHILE (is_true)
        j = 0
    END DO

    do i = 1, 10
      if (diff) go to 100
100 end do

END PROGRAM

----

(translation_unit
  (program
    (program_statement (name))
    (do_loop_statement
      (loop_control_expression (identifier) (number_literal) (number_literal))
      (assignment_statement
        (identifier)
        (math_expression (number_literal) (identifier)))
      (open_statement
       (unit_identifier
        (identifier))
       (keyword_argument (identifier) (string_literal)))
      (subroutine_call
        (identifier)
        (argument_list (identifier) (keyword_argument (identifier) (boolean_literal))))
    (end_do_loop_statement))
    (do_loop_statement
      (loop_control_expression
        (identifier)
        (number_literal)
        (call_expression (identifier) (argument_list (identifier)))
        (identifier))
      (keyword_statement)
      (keyword_statement (statement_label_reference))
    (end_do_loop_statement))
    (do_loop_statement
      (block_label_start_expression)
      (loop_control_expression
        (identifier)
        (number_literal)
        (call_expression
          (identifier)
          (argument_list
            (call_expression (identifier)
              (argument_list
                (math_expression (number_literal) (identifier)))))))
      (do_loop_statement
        (loop_control_expression
          (identifier)
          (number_literal)
          (number_literal)
          (unary_expression (number_literal)))
        (keyword_statement (identifier))
      (end_do_loop_statement))
    (end_do_loop_statement (block_label)))
    (do_loop_statement
      (while_statement
        (parenthesized_expression
          (identifier )))
      (assignment_statement
        (identifier) (number_literal))
      (end_do_loop_statement))
    (do_loop_statement
      (loop_control_expression
        (identifier) (number_literal) (number_literal))
      (if_statement
        (parenthesized_expression (identifier))
        (keyword_statement (statement_label_reference)))
      (statement_label)
      (end_do_loop_statement))
  (end_program_statement)))

============================================
Do Concurrent Statement
============================================

PROGRAM TEST
  INTEGER,DIMENSION(N) :: J, K
  INTEGER              :: I, M
  M = 10
  I = 15
  DO CONCURRENT (I = 1:N, J(I)> 0)  LOCAL (M) SHARED (J, K)
     M =  MOD (K(I), J(I))
     K(I) = K(I) - M
  END DO
  PRINT *, I, M
END PROGRAM TEST

---

(translation_unit
  (program
    (program_statement (name))
    (variable_declaration (intrinsic_type)
      (type_qualifier (argument_list (identifier)))
      (identifier) (identifier))
    (variable_declaration (intrinsic_type) (identifier) (identifier))
    (assignment_statement left: (identifier) right: (number_literal))
    (assignment_statement left: (identifier) right: (number_literal))
    (do_loop_statement
      (concurrent_statement
        (concurrent_header
          (concurrent_control
            (identifier)
            initial: (number_literal)
            final: (identifier))
          (concurrent_mask
            (relational_expression
              left: (call_expression (identifier) (argument_list (identifier)))
              right: (number_literal))))
        (concurrent_locality (identifier))
        (concurrent_locality (identifier) (identifier)))
      (assignment_statement
        left: (identifier)
        right: (call_expression
          (identifier)
          (argument_list
            (call_expression (identifier) (argument_list (identifier)))
            (call_expression (identifier) (argument_list (identifier))))))
      (assignment_statement
        left: (call_expression (identifier) (argument_list (identifier)))
        right: (math_expression
          left: (call_expression (identifier) (argument_list (identifier)))
          right: (identifier)))
      (end_do_loop_statement))
    (print_statement (format_identifier)
      (output_item_list (identifier) (identifier)))
    (end_program_statement (name))))

============================================
Do Label Statement (Obsolescent)
============================================

program test
  do 10 i = 1, 10
    do 10, j = 1, 10
      foo(i, j) = i * j
10 continue
end program test

---

(translation_unit
  (program
    (program_statement (name))
    (do_label_statement
      (statement_label_reference)
      (loop_control_expression (identifier) (number_literal) (number_literal)))
    (do_label_statement
      (statement_label_reference)
      (loop_control_expression (identifier) (number_literal) (number_literal)))
    (assignment_statement
      (call_expression (identifier) (argument_list (identifier) (identifier)))
      (math_expression (identifier) (identifier)))
    (statement_label)
    (keyword_statement)
    (end_program_statement (name))))

============================================
Computed Goto (Obsolescent)
============================================

program test
  goto (10, 20, 30) M
  goto (10, 20, 30) ISAVE(1)
end program

---

(translation_unit
  (program
    (program_statement (name))
    (keyword_statement
      (statement_label_reference) (statement_label_reference) (statement_label_reference)
      (identifier))
    (keyword_statement
      (statement_label_reference) (statement_label_reference) (statement_label_reference)
      (call_expression (identifier) (argument_list (number_literal))))
    (end_program_statement)))

============================================
If Statements
============================================

PROGRAM TEST
  IF (x<7) y = 9
  if(ix.ge.1.and.2.le.nx)x=1.4

  IF (arg(1:1) == ADJUSTL(' r')) THEN
    r = 0
  ELSE IF (arg(1:1) .NE. CHAR(l(1))) THEN
    l = 67
  ELSE IF (arg(1:1) .NE. CHAR(m(1))) THEN
  ELSE
    n = 0
  ENDIF

  cond1: IF (y < 0) THEN
     y = 9
  ELSE  IF (x > 0) THEN cond1
   r = 9
   IF (arg(1:1)) THEN
     r = 0
   ELSE
     n = 0
   END IF
  ELSE cond1
    y = 10
  END IF cond1
END PROGRAM

----

(translation_unit
  (program
    (program_statement (name))
    (if_statement
      (parenthesized_expression (relational_expression (identifier) (number_literal)))
      (assignment_statement (identifier) (number_literal)))
    (if_statement
      (parenthesized_expression
        (logical_expression
          (relational_expression (identifier) (number_literal))
          (relational_expression (number_literal) (identifier))))
    (assignment_statement (identifier) (number_literal)))
    (if_statement
      (parenthesized_expression
        (relational_expression
          (call_expression (identifier)
            (argument_list (extent_specifier (number_literal) (number_literal))))
          (call_expression (identifier)
            (argument_list (string_literal)))))
      (assignment_statement (identifier) (number_literal))
      (elseif_clause
        (parenthesized_expression
          (relational_expression
            (call_expression (identifier)
              (argument_list (extent_specifier (number_literal) (number_literal))))
            (call_expression (identifier)
              (argument_list
                (call_expression (identifier)
                  (argument_list (number_literal)))))))
        (assignment_statement (identifier) (number_literal)))
      (elseif_clause
        (parenthesized_expression
          (relational_expression
            (call_expression (identifier)
              (argument_list (extent_specifier (number_literal) (number_literal))))
            (call_expression (identifier)
              (argument_list
                (call_expression (identifier) (argument_list (number_literal))))))))
      (else_clause
        (assignment_statement (identifier) (number_literal)))
    (end_if_statement))
    (if_statement
      (block_label_start_expression)
      (parenthesized_expression
        (relational_expression (identifier) (number_literal)))
      (assignment_statement (identifier) (number_literal))
      (elseif_clause
        (parenthesized_expression
          (relational_expression (identifier) (number_literal)))
        (block_label)
        (assignment_statement (identifier) (number_literal))
        (if_statement
          (parenthesized_expression
            (call_expression (identifier)
              (argument_list (extent_specifier (number_literal) (number_literal)))))
          (assignment_statement (identifier) (number_literal))
          (else_clause
            (assignment_statement (identifier) (number_literal)))
        (end_if_statement)))
      (else_clause (block_label)
        (assignment_statement (identifier) (number_literal)))
      (end_if_statement (block_label)))
  (end_program_statement)))

============================================
Where Statements
============================================

program test

WHERE(A .NE. 0) C = B / A

WHERE(PRESSURE .GE. 1.0)
  PRESSURE = PRESSURE + 1.0
  TEMP = TEMP - 10.0
ELSEWHERE (PRESSURE .LE. 2.0)
  PRESSURE = PRESSURE - 1.0
ELSEWHERE
  PRECIPITATION = .TRUE.
ENDWHERE

cond1: WHERE(PRESSURE .GE. 1.0)
  PRESSURE = PRESSURE + 1.0
ELSEWHERE (PRESSURE .LE. 2.0) cond1
  PRESSURE = PRESSURE - 1.0
ELSEWHERE cond1
  PRECIPITATION = .TRUE.
ENDWHERE cond1

end program

----

(translation_unit
  (program
    (program_statement (name))
    (where_statement
      (parenthesized_expression (relational_expression (identifier) (number_literal)))
      (assignment_statement (identifier) (math_expression (identifier) (identifier))))
    (where_statement
      (parenthesized_expression (relational_expression  (identifier) (number_literal)))
      (assignment_statement (identifier) (math_expression (identifier) (number_literal)))
      (assignment_statement (identifier) (math_expression (identifier) (number_literal)))
      (elsewhere_clause
        (parenthesized_expression (relational_expression (identifier) (number_literal)))
        (assignment_statement
          (identifier) (math_expression (identifier) (number_literal))))
      (elsewhere_clause
        (assignment_statement (identifier) (boolean_literal)))
    (end_where_statement))
    (where_statement
      (block_label_start_expression)
      (parenthesized_expression (relational_expression (identifier) (number_literal)))
      (assignment_statement
        (identifier) (math_expression (identifier) (number_literal)))
      (elsewhere_clause
        (parenthesized_expression (relational_expression (identifier) (number_literal)))
        (block_label)
        (assignment_statement
          (identifier)
          (math_expression (identifier) (number_literal))))
      (elsewhere_clause (block_label)
        (assignment_statement (identifier) (boolean_literal)))
      (end_where_statement (block_label)))
  (end_program_statement)))

============================================
Forall Statements
============================================

PROGRAM TEST

FORALL(I = 1:N, J = 1:N, A(I, J) .NE. 0.0) B(I, J) = 1.0 / A(I, J)

FORALL(J=1:8)  PATTERN(J)%P => OBJECT(1+IEOR(J-1,2))


FORALL (I = 1:N, J = 1:N)
  WHERE(A(I, J) .NE. 0.0) B(I, J) = 1.0/A(I, J)
END FORALL

FORALL(I = 3:N + 1, J = 3:N + 1, A(I, J) > 0.0)
  C(I, J) = C(I, J + 2) + C(I, J - 2) + C(I + 2, J) + C(I - 2, J)
  D(I, J) = C(I, J)
END FORALL

END PROGRAM

----

(translation_unit
  (program
    (program_statement (name))
    (forall_statement
      (triplet_spec
        (identifier)
        (number_literal)
        (identifier))
      (triplet_spec
        (identifier)
        (number_literal)
        (identifier))
      (relational_expression
        (call_expression
          (identifier)
          (argument_list
            (identifier)
            (identifier)))
        (number_literal))
      (assignment_statement
        (call_expression
          (identifier)
          (argument_list
            (identifier)
            (identifier)))
        (math_expression
          (number_literal)
          (call_expression
            (identifier)
            (argument_list
              (identifier)
              (identifier))))))
    (forall_statement
      (triplet_spec
        (identifier)
        (number_literal)
        (number_literal))
      (pointer_association_statement
        (derived_type_member_expression
          (call_expression
            (identifier)
            (argument_list
              (identifier)))
          (type_member))
        (call_expression
          (identifier)
          (argument_list
            (math_expression
              (number_literal)
              (call_expression
                (identifier)
                (argument_list
                  (math_expression
                    (identifier)
                    (number_literal))
                  (number_literal))))))))
    (forall_statement
      (triplet_spec
        (identifier)
        (number_literal)
        (identifier))
      (triplet_spec
        (identifier)
        (number_literal)
        (identifier))
      (where_statement
        (parenthesized_expression
          (relational_expression
            (call_expression
              (identifier)
              (argument_list
                (identifier)
                (identifier)))
            (number_literal)))
        (assignment_statement
          (call_expression
            (identifier)
            (argument_list
              (identifier)
              (identifier)))
          (math_expression
            (number_literal)
            (call_expression
              (identifier)
              (argument_list
                (identifier)
                (identifier))))))
    (end_forall_statement))
    (forall_statement
      (triplet_spec
        (identifier)
        (number_literal)
        (math_expression
          (identifier)
          (number_literal)))
      (triplet_spec
        (identifier)
        (number_literal)
        (math_expression
          (identifier)
          (number_literal)))
      (relational_expression
        (call_expression
          (identifier)
          (argument_list
            (identifier)
            (identifier)))
        (number_literal))
      (assignment_statement
        (call_expression
          (identifier)
          (argument_list
            (identifier)
            (identifier)))
        (math_expression
          (math_expression
            (math_expression
              (call_expression
                (identifier)
                (argument_list
                  (identifier)
                  (math_expression
                    (identifier)
                    (number_literal))))
              (call_expression
                (identifier)
                (argument_list
                  (identifier)
                  (math_expression
                    (identifier)
                    (number_literal)))))
            (call_expression
              (identifier)
              (argument_list
                (math_expression
                  (identifier)
                  (number_literal))
                (identifier))))
          (call_expression
            (identifier)
            (argument_list
              (math_expression
                (identifier)
                (number_literal))
              (identifier)))))
      (assignment_statement
        (call_expression
          (identifier)
          (argument_list
            (identifier)
            (identifier)))
        (call_expression
          (identifier)
          (argument_list
            (identifier)
            (identifier))))
    (end_forall_statement))
  (end_program_statement)))

============================================
Select Case Statements
============================================

PROGRAM TEST
  sign_case: SELECT CASE (number)
  CASE (: -1) sign_case
    sign = -1
  CASE (0) sign_case
    sign = 0
  CASE (1 :) sign_case
    sign = 1
  END SELECT sign_case

  SELECT CASE (c)
  CASE ('a' : 'm', 'n' : 'z')
    WRITE(*,*) 'lowercase letter'
  CASE ('A' : 'Z')
    WRITE(*,*) 'uppercase letter'
  CASE (WILDCARD_CHAR)
    WRITE(*,*) 'wildcard letter'
  CASE DEFAULT
    WRITE(*,*)  'Other characters, which may not be letters'
  END SELECT
END PROGRAM

----

(translation_unit
  (program
    (program_statement (name))
    (select_case_statement (block_label_start_expression) (selector (identifier))
      (case_statement (case_value_range_list (extent_specifier (unary_expression (number_literal))))
        (block_label)
        (assignment_statement (identifier) (unary_expression (number_literal))))
      (case_statement (case_value_range_list (number_literal))
        (block_label)
        (assignment_statement (identifier) (number_literal)))
      (case_statement (case_value_range_list (extent_specifier (number_literal)))
        (block_label)
        (assignment_statement (identifier) (number_literal)))
      (end_select_statement (block_label)))
    (select_case_statement (selector (identifier))
      (case_statement
        (case_value_range_list
          (extent_specifier (string_literal) (string_literal))
          (extent_specifier (string_literal) (string_literal)))
        (write_statement
          (unit_identifier)
          (format_identifier)
          (output_item_list (string_literal))))
      (case_statement
        (case_value_range_list (extent_specifier (string_literal) (string_literal)))
        (write_statement
          (unit_identifier)
          (format_identifier)
          (output_item_list (string_literal))))
      (case_statement (case_value_range_list (identifier))
        (write_statement
          (unit_identifier)
          (format_identifier)
          (output_item_list (string_literal))))
      (case_statement (default)
        (write_statement
          (unit_identifier)
          (format_identifier)
          (output_item_list (string_literal))))
      (end_select_statement))
  (end_program_statement)))

============================================
Format Statements
============================================

PROGRAM TEST
1 FORMAT('1234', a5, a5a5)
2 FORMAT(2F8.3, F6.2, //, :)
3 FORMAT(I0, A(2X, I3), 'test')
4 FORMAT(*(G15.8,:,','))
5 FORMAT(/1X,'NUMBER OF DATA Total/ACCEPTED'/1X,i10/1X)
6 FORMAT(3(1H-), 2HOK, 10H SOLUTION // 5D15.7)
END PROGRAM

----

(translation_unit
  (program
    (program_statement (name))
    (statement_label)
    (format_statement
      (transfer_items (string_literal) (edit_descriptor) (edit_descriptor)))
    (statement_label)
    (format_statement
      (transfer_items
        (edit_descriptor)
        (edit_descriptor)
        (edit_descriptor)
        (edit_descriptor)))
    (statement_label)
    (format_statement
      (transfer_items
        (edit_descriptor)
        (edit_descriptor)
        (edit_descriptor)
        (edit_descriptor)
        (string_literal)))
    (statement_label)
    (format_statement
      (transfer_items
        (edit_descriptor)
        (edit_descriptor)
        (edit_descriptor)
        (string_literal)))
    (statement_label)
    (format_statement
      (transfer_items
        (edit_descriptor)
        (string_literal)
        (edit_descriptor)
        (edit_descriptor)))
    (statement_label)
    (format_statement
      (transfer_items
        (edit_descriptor)
        (hollerith_constant)
        (hollerith_constant)
        (hollerith_constant)
        (edit_descriptor)
        (edit_descriptor)))
  (end_program_statement)))

============================================
Read Statements
============================================

PROGRAM TEST
  READ *, x
  READ 9, x
  READ(*)
  READ(*, *)
  READ(10, 100) x, y, z
  READ(10,*,iostat=ioerr)
  READ(IOUNIT, FMT="(FORMAT STRING)") flags(:)
  READ(UNIT=IOUNIT, FMT="(FORMAT STRING)", IOSTAT=IOS, ADVANCE='NO') X
END PROGRAM

----

(translation_unit
  (program
    (program_statement (name))
    (read_statement (format_identifier) (input_item_list (identifier)))
    (read_statement
      (format_identifier (statement_label_reference))
      (input_item_list (identifier)))
    (read_statement (unit_identifier))
    (read_statement (unit_identifier) (format_identifier))
    (read_statement
      (unit_identifier (number_literal))
      (format_identifier (statement_label_reference))
      (input_item_list (identifier) (identifier) (identifier)))
    (read_statement
        (unit_identifier (number_literal))
        (format_identifier)
        (keyword_argument  (identifier) (identifier)))
    (read_statement
      (unit_identifier (identifier))
      (keyword_argument (identifier) (string_literal))
      (input_item_list (call_expression (identifier) (argument_list (extent_specifier)))))
    (read_statement
      (keyword_argument (identifier) (identifier))
      (keyword_argument (identifier) (string_literal))
      (keyword_argument (identifier) (identifier))
      (keyword_argument (identifier) (string_literal))
      (input_item_list (identifier)))
  (end_program_statement)))

============================================
Print Statements
============================================

PROGRAM TEST
  PRINT *
  PRINT *, 'test'
  PRINT IUNIT, x, y, z
END PROGRAM

----

(translation_unit
  (program
    (program_statement (name))
    (print_statement (format_identifier))
    (print_statement (format_identifier) (output_item_list (string_literal)))
    (print_statement
      (format_identifier (identifier))
      (output_item_list (identifier) (identifier) (identifier)))
  (end_program_statement)))

============================================
Write Statements
============================================

PROGRAM TEST
  WRITE(*)
  WRITE(*, *) ''
  WRITE(10, 100) x, y, z
  WRITE(IOUNIT, "(FORMAT STRING)", IOSTAT=IOS)
  WRITE(IOUNIT, FMT="(FORMAT STRING)") flags(:)
  WRITE(UNIT=IOUNIT, FMT="(FORMAT STRING)", IOSTAT=IOS, ADVANCE='NO') X
END PROGRAM

----

(translation_unit
  (program
    (program_statement (name))
    (write_statement (unit_identifier))
    (write_statement
      (unit_identifier)
      (format_identifier)
      (output_item_list (string_literal)))
    (write_statement
      (unit_identifier (number_literal))
      (format_identifier (statement_label_reference))
      (output_item_list (identifier) (identifier) (identifier)))
    (write_statement
      (unit_identifier (identifier))
      (format_identifier (string_literal))
      (keyword_argument (identifier) (identifier)))
    (write_statement
      (unit_identifier (identifier))
      (keyword_argument (identifier) (string_literal))
      (output_item_list
        (call_expression (identifier) (argument_list (extent_specifier)))))
    (write_statement
      (keyword_argument (identifier) (identifier))
      (keyword_argument (identifier) (string_literal))
      (keyword_argument (identifier) (identifier))
      (keyword_argument (identifier) (string_literal))
      (output_item_list (identifier)))
  (end_program_statement)))

============================================
Import Statements
============================================

function test()
  import :: dp, cptr
end function test
function test2()
  import c_size_t, c_ptr
end function test2
function test3(self)
  import
  class(self_type), intent(inout) :: self
end function test3
function test4()
  import, only : dp
end function test4

----

(translation_unit
  (function
    (function_statement (name))
    (import_statement (identifier) (identifier))
    (end_function_statement (name)))
  (function
    (function_statement (name))
    (import_statement (identifier) (identifier))
    (end_function_statement (name)))
  (function
    (function_statement (name) (parameters (identifier)))
    (import_statement)
    (variable_declaration (derived_type (type_name)) (type_qualifier) (identifier))
    (end_function_statement (name)))
  (function
    (function_statement (name))
    (import_statement (identifier))
    (end_function_statement (name))))

============================================
Common Statement
============================================

PROGRAM TEST
  COMMON /blk1/ m, n /blk2/ o
  COMMON p
END PROGRAM

----

(translation_unit
  (program
    (program_statement (name))
    (common_statement
      (variable_group (name) (identifier) (identifier))
      (variable_group (name) (identifier)))
    (common_statement (identifier))
    (end_program_statement)))

============================================
Namelist Statement
============================================

PROGRAM TEST
  INTEGER :: i, j
  REAL :: a, b
  namelist /test/ i,j /test2/ a,b
END PROGRAM

----

(translation_unit
  (program
    (program_statement (name))
    (variable_declaration (intrinsic_type) (identifier) (identifier))
    (variable_declaration (intrinsic_type) (identifier) (identifier))
    (namelist_statement
      (variable_group (name) (identifier) (identifier))
      (variable_group (name) (identifier) (identifier)))
    (end_program_statement)))

============================================
Enum Statements
============================================

PROGRAM test
    ENUM, BIND(C)
        ENUMERATOR :: red = 1
        ENUMERATOR blue, green
    END ENUM
    ENUM, BIND(C)
        ENUMERATOR :: minus_one = -1
    END ENUM
END PROGRAM test

----

(translation_unit
  (program
    (program_statement (name))
    (enum
      (enum_statement (language_binding (identifier)))
      (enumerator_statement (identifier) (number_literal))
      (enumerator_statement (identifier) (identifier))
      (end_enum_statement))
    (enum
      (enum_statement (language_binding (identifier)))
      (enumerator_statement (identifier) (unary_expression (number_literal)))
      (end_enum_statement))
    (end_program_statement (name))))

============================================
Select Type Statement
============================================

subroutine print_decorated_numbers(number)
  class(*), intent(in) :: number

  select type(number)
  type is (integer)
    write(*, '("<", i0, ">")') number
  type is (real(kind(1.0)))
    write(*, '("(", f8.5, ")")') number
  type is (real(kind(1.0d0)))
    write(*, '("{", f13.8, "}")') number
  type is (complex)
    write(*, '("[", f13.8, " + ", f13.8 "i]")') number
  class is (custom_type)
    write(*, '("#", f8.5, "#")') number%value
  class default
    write(*, '("~Not a number~")')
  end select
end subroutine print_decorated_numbers

---

(translation_unit
  (subroutine
    (subroutine_statement (name) (parameters (identifier)))
    (variable_declaration (derived_type (unlimited_polymorphic)) (type_qualifier) (identifier))
    (select_type_statement
      (selector (identifier))
      (type_statement (intrinsic_type)
        (write_statement (unit_identifier) (format_identifier (string_literal))
          (output_item_list (identifier))))
      (type_statement (intrinsic_type)
        (size (argument_list (call_expression (identifier) (argument_list (number_literal)))))
        (write_statement (unit_identifier) (format_identifier (string_literal))
          (output_item_list (identifier))))
      (type_statement (intrinsic_type)
        (size (argument_list (call_expression (identifier) (argument_list (number_literal)))))
        (write_statement (unit_identifier) (format_identifier (string_literal))
          (output_item_list (identifier))))
      (type_statement (intrinsic_type)
        (write_statement (unit_identifier) (format_identifier (string_literal))
          (output_item_list (identifier))))
      (type_statement (identifier)
        (write_statement (unit_identifier) (format_identifier (string_literal))
          (output_item_list (derived_type_member_expression (identifier) (type_member)))))
      (type_statement (default)
        (write_statement (unit_identifier) (format_identifier (string_literal))))
      (end_select_statement))
    (end_subroutine_statement (name))))

============================================
Open/Close statements
============================================

program test
  integer :: unit

  open(newunit=unit, file="foo.txt")
  close(unit, status="delete")

  open(newunit=unit, file="foo.txt")
  close(unit=unit, status="delete")

  open(99)
  close(99)
end program test

---

(translation_unit
  (program
    (program_statement (name))
    (variable_declaration (intrinsic_type) (identifier))
    (open_statement
      (keyword_argument (identifier) (identifier))
      (keyword_argument (identifier) (string_literal)))
    (close_statement
      (unit_identifier (identifier))
      (keyword_argument (identifier) (string_literal)))
    (open_statement
      (keyword_argument (identifier) (identifier))
      (keyword_argument (identifier) (string_literal)))
    (close_statement
      (keyword_argument (identifier) (identifier))
      (keyword_argument (identifier) (string_literal)))
    (open_statement
      (unit_identifier (number_literal)))
    (close_statement
      (unit_identifier (number_literal)))
    (end_program_statement (name))))

============================================
Select Rank and Assumed Rank
============================================

subroutine assumed_rank(A)
  integer, intent(inout) :: A(..)

  select rank(A)
    rank (0)
      write(*, *) "scalar"
    rank (1)
      write(*, *) "rank 1"
    rank (2)
      write(*, *) "rank 2"
    rank default
      error stop 'assumed_rank: only rank 0..2 is handled for now.'
  end select
end subroutine assumed_rank

---

(translation_unit
  (subroutine
    (subroutine_statement (name)
      (parameters (identifier)))
    (variable_declaration (intrinsic_type)
      (type_qualifier)
      (call_expression (identifier) (argument_list (assumed_rank))))
    (select_rank_statement (selector (identifier))
      (rank_statement
        (case_value_range_list (number_literal))
        (write_statement
          (unit_identifier)
          (format_identifier)
          (output_item_list (string_literal))))
      (rank_statement
        (case_value_range_list (number_literal))
        (write_statement
          (unit_identifier)
          (format_identifier)
          (output_item_list (string_literal))))
      (rank_statement (case_value_range_list (number_literal))
        (write_statement
          (unit_identifier)
          (format_identifier)
          (output_item_list (string_literal))))
      (rank_statement (default)
        (stop_statement (string_literal)))
      (end_select_statement))
    (end_subroutine_statement (name))))

============================================
Preprocessed Files
============================================

# 1 "/path/some/file.F90"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "/path/some/file.F90" 1
program test
end program test

---

(translation_unit
  (preproc_file_line (preproc_line_number) (preproc_filename))
  (preproc_file_line (preproc_line_number) (preproc_filename))
  (preproc_file_line (preproc_line_number) (preproc_filename))
  (preproc_file_line (preproc_line_number) (preproc_filename))
  (program
    (program_statement (name))
    (end_program_statement (name))))

============================================
Associate Statement
============================================

program test
  associate(foo => bar, bing => bat)
    inner:associate(this => that%other())
        foo = this + 1
    end associate inner
  end associate
end program

---

(translation_unit
  (program
    (program_statement (name))
    (associate_statement
      (association
        (identifier)
        (identifier))
      (association
        (identifier)
        (identifier))
      (associate_statement
        (block_label_start_expression)
        (association
          (identifier)
          (call_expression
            (derived_type_member_expression
              (identifier) (type_member))
            (argument_list)))
        (assignment_statement
          (identifier)
          (math_expression (identifier) (number_literal)))
        (end_associate_statement (block_label)))
      (end_associate_statement))
    (end_program_statement)))

============================================
User Defined Operator
============================================

program foo
  interface operator(.unary.)
    integer function unary_op(x)
      integer, intent(in) :: x
    end function unary_op
  end interface

  interface operator(.binary.)
    integer function binary_op(x, y)
      integer, intent(in) :: x, y
    end function unary_op
  end interface

  integer :: a, b
  print*, . unary . a
  print*, b .binary. a

end program

---

(translation_unit
  (program
    (program_statement (name))
    (interface 
      (interface_statement (operator))
      (function
        (function_statement (intrinsic_type)
          (name) (parameters (identifier)))
        (variable_declaration (intrinsic_type)
          (type_qualifier) (identifier))
         (end_function_statement (name)))
      (end_interface_statement))
    (interface 
      (interface_statement (operator))
      (function
        (function_statement (intrinsic_type)
          (name) (parameters (identifier) (identifier)))
        (variable_declaration (intrinsic_type)
          (type_qualifier) (identifier) (identifier))
         (end_function_statement (name)))
      (end_interface_statement))
    (variable_declaration (intrinsic_type) (identifier) (identifier))
    (print_statement (format_identifier)
      (output_item_list
        (unary_expression
          (user_defined_operator) (identifier))))
    (print_statement (format_identifier)
      (output_item_list
        (math_expression
          (identifier) (user_defined_operator) (identifier))))
    (end_program_statement)))

============================================
Defined IO Procedures
============================================

module test
  use other, only : write(unformatted), read(formatted)
  implicit none

  public :: read(unformatted)
  private :: write(formatted)

  interface write(formatted)
    module procedure :: write_formatted
  end interface

  interface read(formatted)
    module procedure read_formatted
  end interface read(formatted)

  type foo
  contains
    ! User defined IO
    generic, public :: write(formatted) => write_formatted
    ! Just some function called read
    procedure, public :: read => read_foo
  end type foo
end module

---

(translation_unit
  (module
    (module_statement (name))
    (use_statement (module_name)
      (included_items
        (defined_io_procedure)
        (defined_io_procedure)))
    (implicit_statement (none))
    (public_statement (defined_io_procedure))
    (private_statement (defined_io_procedure))
    (interface
      (interface_statement (defined_io_procedure))
      (procedure_statement (method_name))
      (end_interface_statement))
    (interface
      (interface_statement (defined_io_procedure))
      (procedure_statement (method_name))
      (end_interface_statement (defined_io_procedure)))
    (derived_type_definition
      (derived_type_statement (type_name))
      (derived_type_procedures
        (contains_statement)
        (comment)
        (procedure_statement
          (procedure_attribute)
          (binding_name (defined_io_procedure))
          (method_name))
        (comment)
        (procedure_statement
          (procedure_attribute)
          (binding_name (identifier))
          (method_name)))
      (end_type_statement (name)))
    (end_module_statement)))

============================================
Data statement
============================================

program test
  data a, b /1, 2/, c /3, 4/
  data list / null() /
  data bool / .true. /
  data foo%bar / "hello" /
  DATA person / Person_t(42, "Test Name") /
  DATA (array(1,k),k=1,n) /3.14e-3, -42.5/
  DATA array(:, N) / &
    54.45_fp, 200.01_fp /
  DATA complex_array / ( 0, 1 ), ( 1, 0 ) /
  data params/ param1, param2/

  ! This is awful, but this makes sure the specification part has
  ! finished, as is a hacky workaround to make sure the next part is
  ! parsed correctly
  x = 4

  ! Check data is still ok as identifier
  data(n) = 54
end program test

---

(translation_unit
  (program
    (program_statement (name))
    (data_statement
      (data_set
        (identifier) (identifier)
        (data_value (number_literal) (number_literal)))
      (data_set
        (identifier)
        (data_value (number_literal) (number_literal))))
    (data_statement
      (data_set
        (identifier)
        (data_value (null_literal))))
    (data_statement
      (data_set
        (identifier)
        (data_value (boolean_literal))))
    (data_statement
      (data_set
        (derived_type_member_expression (identifier) (type_member))
        (data_value (string_literal))))
    (data_statement
      (data_set
        (identifier)
        (data_value
          (call_expression
            (identifier)
            (argument_list (number_literal) (string_literal))))))
    (data_statement
      (data_set
        (implied_do_loop_expression
          (call_expression
            (identifier)
            (argument_list (number_literal) (identifier)))
          (loop_control_expression
            (identifier) (number_literal) (identifier)))
        (data_value (number_literal) (unary_expression (number_literal)))))
    (data_statement
      (data_set
        (call_expression (identifier) (argument_list (extent_specifier) (identifier)))
        (data_value
          (number_literal) (number_literal))))
    (data_statement
      (data_set
        (identifier)
        (data_value (complex_literal (number_literal) (number_literal))
                    (complex_literal (number_literal) (number_literal)))))
    (data_statement
      (data_set (identifier)
        (data_value (identifier) (identifier))))
    (comment)
    (comment)
    (comment)
    (assignment_statement (identifier) (number_literal))
    (comment)
    (assignment_statement
      (call_expression (identifier) (argument_list (identifier)))
      (number_literal))
    (end_program_statement (name))))

============================================
File Position Statments
============================================

program test
  backspace 2
  backspace (10, iostat=N)

  endfile k
  endfile (unit=self%scratch, iostat=error)

  rewind(11)
  rewind(lu_prof(N))

  pause 'this is deleted'
end program

---

(translation_unit
  (program
    (program_statement (name))
    (file_position_statement (unit_identifier (number_literal)))
    (file_position_statement
      (unit_identifier (number_literal))
      (keyword_argument (identifier) (identifier)))
    (file_position_statement (unit_identifier (identifier)))
    (file_position_statement
      (keyword_argument (identifier) (derived_type_member_expression (identifier) (type_member)))
      (keyword_argument (identifier) (identifier)))
    (file_position_statement (unit_identifier (parenthesized_expression (number_literal))))
    (file_position_statement (unit_identifier
      (parenthesized_expression (call_expression (identifier) (argument_list (identifier))))))
    (file_position_statement (string_literal))
    (end_program_statement)))

========================================
Inquire Statements
========================================

program test
  INQUIRE (IOLENGTH = IOL) A (1:N)
  INQUIRE (UNIT = JOAN, OPENED = LOG_01, NAMED = LOG_02, &
           FORM = CHAR_VAR, IOSTAT = IOS)
end program test

---

(translation_unit
  (program
    (program_statement (name))
    (inquire_statement
      (keyword_argument (identifier) (identifier))
      (output_item_list
        (call_expression (identifier)
          (argument_list (extent_specifier (number_literal) (identifier))))))
    (inquire_statement
      (keyword_argument (identifier) (identifier))
      (keyword_argument (identifier) (identifier))
      (keyword_argument (identifier) (identifier))
      (keyword_argument (identifier) (identifier))
      (keyword_argument (identifier) (identifier)))
    (end_program_statement (name))))

========================================
Arithmetic If Statement (Deleted)
========================================

  if (d) 10, 20, 30
end

---

(translation_unit
  (program
    (arithmetic_if_statement
      (parenthesized_expression (identifier))
      (statement_label_reference) (statement_label_reference) (statement_label_reference))
    (end_program_statement)))
